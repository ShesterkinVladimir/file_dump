;я слегка изменил вашу программу. Теперь имя процедуры задано меткой label,
; вызовите эту процедуру из основной части кода (PSEG), используя имя, заданное меткой.

;Шестеркин В. A-08-17
;Pазличные виды меток в .COM-программе.

.model tiny 

.code
org 100h

start:
	
xor dx,dx
xor ax,ax
mov cx,n ; заносим в счетчик длину массива 
mov bx, offset mas ; в bx помещаем адрес начала массива 


L: ;цикл суммирующий элементы массива

add ax,[bx]; добавляем элемент к общей сумме 
adc dx,zero; если переном то +1 к dx
add bx, step ; переходим к следующему элементу 
LOOP L ; продолжаем пока не прошли все элементы массива 

mm:
xor bx,bx 
mov bx, n ; помещаем длину массива 
div bx ; ax = (dx:ax)/bx  

;ВЫЗОВ ФУНКЦИИ 



push cs
push offset(m1)

mov dx, offset(newseg) ; в DХ загружается смещение, следующее за концом программы
test dx, 0Fh ; проверяем, является ли это смещение кратным 16, т.к. Использован атрибут выравнивания PARA 
jnz m ; если да, то просто сдвигаем на 4 бита вправо - получаем разность сегмента первого стека и текущего сегмента

shr  dx, 1
shr  dx, 1
shr  dx, 1
shr  dx, 1
jmp nn ; иначе после сдвига еще прибавляем 1
m:
shr  dx, 1
shr  dx, 1
shr  dx, 1
shr  dx, 1
add dx, 1
nn:
;в dx записана разность между текущим и искомым сегментом 
mov cx,cs ;текущий сегмент 
add dx,cx ;получаем сегмент в котором находится процедура 
push dx
push 0000h
retf


m1:
int 20h ; выходим из com программы 

mas dw 6400,4444,2333,31111 ; массив , который суммируем 
n equ 4 ;длина массива 
sist equ 10 ; система исчисления для вывода ( до 10-ой включительно ) 
step = 2 ;шаг для массива 
zero = 0 ; и пользуется для adc

	
newseg:

PCODE segment para public 'CODE'

assume cs:PCODE

outproc label far

xor cx,cx ;обнуляем счетчик 
mov bx,10 ;задаем систему исчисления для вывода 

vivod:	
xor dx,dx 
div bx ; делим ax 
push dx ; помещаем остаток в стек 
inc cx ; считаем , сколько поместили в стек 
test ax,ax ; устанавливаем флаги 
jnz vivod ;если ax еще не 0 , то продолжаем делить и помещать в стек 

mov ah,02h; Эта функция предназначена для вывода символа
vivodvkons:
pop dx ; достаем из стека цифру
add dl, 30h ; переводим в "правильную" кодировку 
int 21h ; на этом этапе в этой переменной 21h 
loop vivodvkons ; продолжаем выводим, пока в стеке есть значения 
mov sp,0FFFAh
retf

PCODE ends

end Start				


