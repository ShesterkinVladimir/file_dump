;Шестеркин В. A-08-17
;Pазличные виды меток в .COM-программе.

.model tiny 
PROG SEGMENT ;начало сегмента PROG
ASSUME cs:PROG, ds:PROG, ss:PROG, es:PROG ;указываем в значении какого сегмента установлены сегментные регистры

org 100h
start:
xor dx,dx
xor ax,ax
mov cx,n ; заносим в счетчик длину массива 
mov bx, offset mas ; в bx помещаем адрес начала массива 


L: ;цикл суммирующий элементы массива

add ax,[bx]; добавляем элемент к общей сумме 
adc dx,zero; если переном то +1 к dx
add bx, step ; переходим к следующему элементу 
LOOP L ; продолжаем пока не прошли все элементы массива 


xor bx,bx 
mov bx, n ; помещаем длину массива 
div bx ; ax = (dx:ax)/bx  

call Outproc ;передаем управление процедуре вывода 
	
int 20h ; выходим из com программы 

Outproc proc

xor cx,cx ;обнуляем счетчик 
mov bx,sist ;задаем систему исчисления для вывода 

vivod:
xor dx,dx 
div bx ; делим ax 
push dx ; помещаем остаток в стек 
inc cx ; считаем , сколько поместили в стек 
test ax,ax ; устанавливаем флаги 
jnz vivod ;если ax еще не 0 , то продолжаем делить и помещать в стек 

mov ah,02h; Эта функция предназначена для вывода символа
vivodvkons:
pop dx ; достаем из стека цифру
add dl, 30h ; переводим в "правильную" кодировку 
int 21h ; на этом этапе в этой переменной 21h 
loop vivodvkons ; продолжаем выводим, пока в стеке есть значения 
ret
endp

mas dw 6400,4444,2333,31111 ; массив , который суммируем 
n equ 4 ;длина массива 
sist equ 10 ; система исчисления для вывода ( до 10-ой включительно ) 
step = 2 ;шаг для массива 
zero = 0 ; и пользуется для adc
PROG ENDS ;конец сегмента PROG
end Start				

